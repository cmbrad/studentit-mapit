<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<script src="track_transforms.js"></script>
<script src="resource-map.js"></script>

<dom-module id="bookit-map">
	<template>
		<style>
			:host {
				display: block;
				height: 100%;
			}

			#container {
				display: flex;
				height: 100%;
				align-items: center;
				justify-content: center;

				background-color: #E0E0E0;
				font-size: 24px;
			}

			#map, #info {
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#info {
				display: flex;
				align-items: center;
				justify-content: center;
			}

			#bookit_embed {
				height: 100%;
				width: 100%;
			}
		</style>

		<div id="container">
			<div id="info" hidden$="[[!hideMap]]">
				<div>
					<span>Select a resource to begin</span>
				</div>
			</div>
			<div id="map" on-track="_handleMapTrack" on-scroll="_handleMapScroll"
			     on-dragover="_handleDragover" on-drop="_handleDrop"
			     on-mousewheel="_handleMouseWheel" hidden="[[hideMap]]"
			     on-touchstart="_handleTouchStart" on-touchmove="_handleTouchMove"
			     on-touchend="_handleTouchEnd"></div>
		</div>
	</template>
	
	<script>
		(function() {
			'use strict';

			Polymer({
				is: 'bookit-map',

				properties: {
					site: {
						type: String,
						observer: '_siteChanged'
					},
					focusResource: {
						type: String,
						observer: '_focusResourceChanged'
					},
					resources: {
						type: Object,
						observer: '_resourcesChanged'
					},
					map: {
						type: Object,
						notify: true,
						value: null
					},
					hideMap: {
						type: Boolean,
						value: true
					},
					xPos: {
						type: Number,
						value: 0,
						notify: true,
						reflectToAttribute: true
					},
					yPos: {
						type: Number,
						value: 0,
						notify: true,
						reflectToAttribute: true
					},
					zoom: {
						type: Number,
						value: 1.0,
						observer: '_zoomChanged',
						notify: true
					},
					maxZoom: {
						type: Number,
						value: 10.0,
						notify: true
					},
					minZoom: {
						type: Number,
						value: 0.2,
						notify: true
					},
					scaling: {
						type: Number,
						value: null
					}
				},

				behaviors: [
					Polymer.IronResizableBehavior
				],
				listeners: {
					'iron-resize': 'resize'
				},

				attached: function() {
					this._initMap();
				},

				_handleDragover: function(e) {
					e.preventDefault();
				},

				_handleDrop: function(e) {
					var data = e.dataTransfer.getData('text/html');
					this.map.moveResource(data, e.offsetX, e.offsetY);
				},

				_handleTouchStart: function(e) {
					if (e.touches.length === 2) {
						this.scaling =
							Math.sqrt(
								(e.touches[0].clientX-e.touches[1].clientX) * (e.touches[0].clientX-e.touches[1].clientX) +
								(e.touches[0].clientY-e.touches[1].clientY) * (e.touches[0].clientY-e.touches[1].clientY));
					}
				},
				_handleTouchMove: function(e) {
					if (this.scaling !== null) {
						var x = 0;
						var y = 0;

						for (var i = 0; i < e.touches.length; i++) {
							x += e.touches[i].pageX - e.touches[i].target.offsetLeft;
							y += e.touches[i].pageY - e.touches[i].target.offsetTop;
						}

						console.log(e);
						var dist =
							Math.sqrt(
								(e.touches[0].clientX-e.touches[1].clientX) * (e.touches[0].clientX-e.touches[1].clientX) +
								(e.touches[0].clientY-e.touches[1].clientY) * (e.touches[0].clientY-e.touches[1].clientY));

						x /= e.touches.length;
						y /= e.touches.length;

						var factor = dist - this.scaling;

						console.log(factor / 12);

						this.map.setZoom(x, y, factor / 12);

						this.scaling = dist;
					}
				},
				_handleTouchEnd: function() {
					this.scaling = null;
				},

				_handleMouseWheel: function(e) {
					var delta = e.wheelDelta ? e.wheelDelta/40 : e.detail ? -e.detail : 0;
					console.log(delta);
					this.map.setZoom(e.offsetX, e.offsetY, delta);
				},

				_initMap: function() {
					if (this.map) {
						console.log('Map already initialized.');
						return;
					}
					if (!this.isAttached) {
						console.log('Map is not attached.');
						return;
					}
					/*global ResourceMap */
					this.map = new ResourceMap(this.site);
				},

				_zoomChanged: function() {
					if (this.map) {
						this.map.setZoom(Number(this.zoom));
					}
				},

				_siteChanged: function(newSite) {
					if (newSite !== '') {
						this.resource = null;
						this.hideMap = true;
						this.map.setLocation(newSite);
					}
				},

				_focusResourceChanged: function(resource) {
					if (this.map && resource) {
						this.hideMap = false;
						this.map.centerOnResource(resource);
					}
				},

				_resourcesChanged: function(resources) {
					if(resources.length === 0) {
						return;
					}

					var rs = [];
					for (var l in resources[0].locations) {
						var location = resources[0].locations[l];
						rs = rs.concat(location.resources);
					}
	
					this.map.resourceUpdate(rs);
				},

				_handleMapTrack: function(e) {
					switch(e.detail.state) {
						case 'start':
							this.map.startMove(e.detail.x, e.detail.y);
							break;
						case 'track':
							if (!this.scaling) {
								this.map.doMove(e.detail.x, e.detail.y);
							}
							break;
						case 'end':
							this.map.endMove();
							break;
					}
				},

				resize: function() {
					if(this.map) {
						this.map.resizeCanvas();
					}
				}
			});
		})();
	</script>
</dom-module>
