<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">

<script src="track_transforms.js"></script>
<script src="resource-map.js"></script>

<dom-module id="bookit-map">
	<template>
		<style>
			:host {
				display: block;
				height: 100%;
			}

			#container {
				display: flex;
				height: 100%;
				align-items: center;
				justify-content: center;

				background-color: #E0E0E0;
				font-size: 24px;
			}

			#map, #info {
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#info {
				display: flex;
				align-items: center;
				justify-content: center;
			}

			#bookit_embed {
				height: 100%;
				width: 100%;
			}

			map-levelselector {
				position: absolute;
				left: 0;
				top: 112px;
				padding: 16px 16px;
			}

			paper-spinner {
				width: 60px;
				height: 60px;
			}
		</style>

		<div id="container">
			<map-levelselector map-data="[[mapData]]" selected="{{level}}"></map-levelselector>

			<div id="loading" hidden="[[!isLoading]]">
				<paper-spinner alt="Loading resource list" active></paper-spinner>
			</div>

			<div id="map" on-track="_handleMapTrack" on-scroll="_handleMapScroll"

			     on-dragover="_handleDragover" on-drop="_handleDrop"
			     on-mousewheel="_handleMouseWheel" on-touchstart="_handleTouchStart"
			     on-touchmove="_handleTouchMove" on-touchend="_handleTouchEnd"
			     hidden="[[isLoading]]">
			</div>
		</div>
	</template>
	
	<script>
		(function() {
			'use strict';

			Polymer({
				is: 'bookit-map',

				properties: {
					site: {
						type: String,
						observer: '_siteChanged'
					},
					focusResource: {
						type: String,
						observer: '_focusResourceChanged'
					},
					resources: {
						type: Object,
						observer: '_resourcesChanged'
					},
					mapData: {
						type: Object,
						observer: '_mapDataChanged'
					},
					level: {
						type: Number,
						observer: '_levelChanged'
					},
					
					map: {
						type: Object,
						notify: true,
						value: null
					},
					scaling: {
						type: Number,
						value: null
					},
					isLoading: {
						type: Boolean,
						value: true
					}
				},

				behaviors: [
					Polymer.IronResizableBehavior
				],
				listeners: {
					'iron-resize': 'resize'
				},

				attached: function() {
					// the meaning of this changes inside event listeners.
					var that = this;
					document.querySelector('#map').addEventListener('map-loading', function() {
						that.isLoading = true;
					}, false);

					document.querySelector('#map').addEventListener('map-loaded', function() {
						that.isLoading = false;

						// Hiding and unhiding the div changes the size. Make sure
						// the map canvas is resized to accomodate
						if(that.map) {
							that.map.resizeCanvas();
						}
					}, false);
				},

				_handleDragover: function(e) {
					e.preventDefault();
				},

				_handleDrop: function(e) {
					var data = e.dataTransfer.getData('text/html');
					this.map.moveResource(data, e.offsetX, e.offsetY);
				},

				_handleTouchStart: function(e) {
					if (e.touches.length === 2) {
						this.scaling =
							Math.sqrt(
								(e.touches[0].clientX-e.touches[1].clientX) * (e.touches[0].clientX-e.touches[1].clientX) +
								(e.touches[0].clientY-e.touches[1].clientY) * (e.touches[0].clientY-e.touches[1].clientY));
					}
				},
				_handleTouchMove: function(e) {
					if (this.scaling !== null) {
						var x = 0;
						var y = 0;

						for (var i = 0; i < e.touches.length; i++) {
							x += e.touches[i].pageX - e.touches[i].target.offsetLeft;
							y += e.touches[i].pageY - e.touches[i].target.offsetTop;
						}

						console.log(e);
						var dist =
							Math.sqrt(
								(e.touches[0].clientX-e.touches[1].clientX) * (e.touches[0].clientX-e.touches[1].clientX) +
								(e.touches[0].clientY-e.touches[1].clientY) * (e.touches[0].clientY-e.touches[1].clientY));

						x /= e.touches.length;
						y /= e.touches.length;

						var factor = dist - this.scaling;

						console.log(factor / 12);

						this.map.setZoom(x, y, factor / 12);

						this.scaling = dist;
					}
				},
				_handleTouchEnd: function() {
					this.scaling = null;
				},

				_handleMouseWheel: function(e) {
					var delta = e.wheelDelta ? e.wheelDelta/40 : e.detail ? -e.detail : 0;
					console.log(delta);
					this.map.setZoom(e.offsetX, e.offsetY, delta);
				},

				_mapDataChanged: function() {
					this._initMap();
					if (this.map) {
						this.map.setMapData(this.mapData);
						this.map.resourceUpdate(this.resources);
						this.map.setLevel(0);
					}
				},

				_levelChanged: function(level) {
					if (this.map) {
						this.map.setLevel(level);
					}
				},

				_initMap: function() {
					if (this.map) {
						console.log('Map already initialized.');
						return;
					}
					if (!this.isAttached) {
						console.log('Map is not attached.');
						return;
					}
					/*global ResourceMap */
					this.map = new ResourceMap(this.site);
				},

				_siteChanged: function(newSite) {
					if (this.map && newSite && newSite !== '') {
						this.resource = null;
						this.map.setLocation(newSite);
					}
				},

				_focusResourceChanged: function(resource) {
					if (this.map && resource) {
						this.map.centerOnResource(resource);
					}
				},

				_resourcesChanged: function(resources) {
					if(!this.map || resources.length === 0) {
						return;
					}

					var rs = [];
					for (var l in resources[0].locations) {
						var location = resources[0].locations[l];
						rs = rs.concat(location.resources);
					}
	
					this.map.resourceUpdate(rs);
				},

				_handleMapTrack: function(e) {
					switch(e.detail.state) {
						case 'start':
							this.map.startMove(e.detail.x, e.detail.y);
							break;
						case 'track':
							if (!this.scaling) {
								this.map.doMove(e.detail.x, e.detail.y);
							}
							break;
						case 'end':
							this.map.endMove();
							break;
					}
				},

				resize: function() {
					if(this.map) {
						this.map.resizeCanvas();
					}
				}
			});
		})();
	</script>
</dom-module>
